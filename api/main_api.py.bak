"""
HandyOsint API - Secure REST API for advanced OSINT intelligence and reconnaissance.
"""

import logging
from dataclasses import dataclass
from typing import Any, Dict, Optional

from fastapi import BackgroundTasks, Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from core.production_scanner import ProductionScanner  # pylint: disable=import-error
from core.integration import IntegrationCoordinator, ScanPriority  # pylint: disable=import-error
from core.job_repository import JobRepository  # pylint: disable=import-error
from core.auth import UserPayload, verify_access_token  # pylint: disable=import-error

# pylint: disable=protected-access

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="HandyOsint API",
    description="Secure REST API for advanced OSINT intelligence and reconnaissance.",
    version="1.1.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_tags=[
        {"name": "health", "description": "Service health & readiness"},
        {"name": "scans", "description": "Submit and manage OSINT scan jobs"},
        {"name": "platforms", "description": "OSINT platform metadata"},
        {"name": "auth", "description": "Authentication and token info"},
    ],
)


@dataclass
class AppState:
    """Container for application-scoped state objects."""
    scanner: Optional[ProductionScanner] = None
    coordinator: Optional[IntegrationCoordinator] = None
    jobs: Optional[JobRepository] = None


state = AppState()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/token")


async def get_current_user(token: str = Depends(oauth2_scheme)) -> UserPayload:
    """
    Decode and validate an access token, returning the user payload.
    """
    try:
        return verify_access_token(token)
    except Exception as exc:  # pylint: disable=broad-except
        logger.warning("Token validation failed: %s", exc)
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
            headers={"WWW-Authenticate": "Bearer"},
        ) from exc


@app.on_event("startup")
async def startup_event() -> None:
    """Initialize scanner, coordinator, and job repository on application startup."""
    logger.info("Initializing ProductionScanner...")
    scanner = ProductionScanner(max_concurrent=10)
    await scanner._ensure_session()
    state.scanner = scanner
    logger.info("ProductionScanner initialized.")

    logger.info("Initializing IntegrationCoordinator...")
    state.coordinator = IntegrationCoordinator()
    logger.info("IntegrationCoordinator initialized.")

    logger.info("Initializing JobRepository...")
    jobs = JobRepository()
    await jobs.connect()
    state.jobs = jobs
    logger.info("JobRepository initialized.")


@app.on_event("shutdown")
async def shutdown_event() -> None:
    """Close scanner session and job repository on application shutdown."""
    if state.scanner:
        logger.info("Closing ProductionScanner session...")
        await state.scanner.close()
        logger.info("ProductionScanner session closed.")

    if state.jobs:
        logger.info("Closing JobRepository...")
        await state.jobs.disconnect()
        logger.info("JobRepository closed.")


@app.get("/health", tags=["health"])
async def health_check() -> Dict[str, str]:
    """Liveness probe."""
    return {"status": "ok"}


@app.get("/", tags=["health"])
async def read_root() -> Dict[str, str]:
    """Root endpoint providing a basic welcome message."""
    return {
        "message": (
            "Welcome to HandyOsint API - Visit /docs for API documentation."
        )
    }


def _background_scan_handler(job_id: str) -> None:
    """
    Placeholder background handler for scan jobs.
    """
    logger.info("Background scan handler invoked for job %s", job_id)


@app.post(
    "/api/v1/scan/{username}",
    response_model=Dict[str, str],
    tags=["scans"],
)
async def scan_username_api(
    username: str,
    background_tasks: BackgroundTasks,
    current_user: UserPayload = Depends(get_current_user),
) -> Dict[str, str]:
    """
    Submit a scan job for a given username across all available platforms.
    """
    del current_user

    if not state.coordinator or not state.jobs:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Service not fully initialized. Please try again in a moment.",
        )

    if not username or not username.strip():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username cannot be empty.",
        )

    try:
        job = state.coordinator.create_batch_job(
            usernames=[username],
            priority=ScanPriority.NORMAL,
        )
        await state.jobs.save_job(
            job_id=job.job_id,
            username=username,
            status="queued",
            raw_payload=None,
        )

        background_tasks.add_task(_background_scan_handler, job.job_id)

        return {"job_id": job.job_id, "status": "job_submitted"}
    except Exception as exc:  # pylint: disable=broad-except
        logger.error(
            "Error submitting scan job for %s: %s",
            username,
            exc,
            exc_info=True,
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=(
                "An error occurred while submitting the scan job: "
                f"{str(exc)}"
            ),
        ) from exc


@app.get(
    "/api/v1/platforms",
    response_model=Dict[str, Any],
    tags=["platforms"],
)
async def get_platforms_info(
    current_user: UserPayload = Depends(get_current_user),
) -> Dict[str, Any]:
    """Retrieve information about all configured OSINT platforms."""
    del current_user

    if not state.scanner:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Scanner not initialized. Please try again in a moment.",
        )

    try:
        return state.scanner.get_platform_info()
    except Exception as exc:  # pylint: disable=broad-except
        logger.error(
            "Error retrieving platform info: %s",
            exc,
            exc_info=True,
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred: {str(exc)}",
        ) from exc


@app.get(
    "/api/v1/jobs/{job_id}/status",
    response_model=Dict[str, Any],
    tags=["scans"],
)
async def get_job_status_api(
    job_id: str,
    current_user: UserPayload = Depends(get_current_user),
) -> Dict[str, Any]:
    """
    Retrieve the status of a specific scan job.
    """
    del current_user

    if not state.coordinator or not state.jobs:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Service not fully initialized.",
        )

    job_status = state.coordinator.get_job_status(job_id)
    if job_status is None:
        stored = await state.jobs.get_job(job_id)
        if not stored:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Job with ID '{job_id}' not found.",
            )
        return stored

    await state.jobs.update_job_status(
        job_id=job_id,
        status=str(job_status.get("status", "unknown")),
    )
    return job_status
